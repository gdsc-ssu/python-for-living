# 4. 기타 제어 흐름 도구

# 4.1 if 문

가장 기본적인 조건 분기문으로, `elif`와 `else`를 함께 사용할 수 있다.

- `elif`는 `else if`의 줄임말로, 과도한 들여쓰기를 방지한다.
- `if … elif … elif …` 시퀀스는 다른 언어의 `switch`/`case` 문을 대신한다.
- `elif`는 0개 이상, `else`는 선택적이다.

```python
x = int(input("Please enter an integer: "))
if x < 0:
    x = 0
    print('Negative changed to zero')
elif x == 0:
    print('Zero')
elif x == 1:
    print('Single')
else:
    print('More')
```

---

# 4.2 for 문

파이썬의 `for`는 **시퀀스(리스트, 문자열 등)의 항목을 순서대로 이터레이션**한다. C처럼 숫자 진행이 아니라 항목 자체를 순회한다.

```python
words = ['cat', 'window', 'defenestrate']
for w in words:
    print(w, len(w))
```

> ⚠️ 컬렉션을 이터레이트하는 동안 같은 컬렉션을 수정하지 말 것! 복사본으로 루프를 만들거나 새 컬렉션을 생성한다.

```python
# 전략 1: 사본을 이터레이트
for user, status in users.copy().items():
    if status == 'inactive':
        del users[user]

# 전략 2: 새 컬렉션 만들기
active_users = {}
for user, status in users.items():
    if status == 'active':
        active_users[user] = status
```

---

# 4.3 range() 함수

숫자 시퀀스를 생성하는 내장 함수. **끝값은 포함되지 않는다.**

```python
range(5)          # 0, 1, 2, 3, 4
range(5, 10)      # 5, 6, 7, 8, 9
range(0, 10, 3)   # 0, 3, 6, 9 (스텝 지정)
range(-10, -100, -30)  # -10, -40, -70 (음수 스텝)
```

**핵심 포인트:**

- `range()`는 리스트가 아닌 **이터러블 객체**를 반환하여 메모리를 절약한다.
- 인덱스 순회 시 `range(len(a))` 대신 `enumerate()`를 사용하는 것이 더 편리하다.
- `sum(range(4))`처럼 이터러블을 인자로 받는 함수와 함께 사용할 수 있다.

---

# 4.4 break와 continue 문

| 키워드 | 동작 |
| --- | --- |
| `break` | 가장 가까운 `for`/`while` 루프를 즉시 탈출 |
| `continue` | 현재 이터레이션을 건너뛰고 다음 이터레이션으로 진행 |

```python
# break 예시: 소인수 찾기
for n in range(2, 10):
    for x in range(2, n):
        if n % x == 0:
            print(f"{n} equals {x} * {n//x}")
            break
```

```python
# continue 예시: 짝수/홀수 구분
for num in range(2, 10):
    if num % 2 == 0:
        print(f"Found an even number {num}")
        continue
    print(f"Found an odd number {num}")
```

---

# 4.5 루프의 else 절

`for`/`while` 루프에 `else`를 붙일 수 있다.

- **`break` 없이** 루프가 정상 종료되면 `else` 절이 실행된다.
- `break`로 루프가 중단되면 `else`는 실행되지 않는다.
- `try` 문의 `else`와 유사: 예외가 없으면 실행 / break가 없으면 실행

```python
for n in range(2, 10):
    for x in range(2, n):
        if n % x == 0:
            print(n, 'equals', x, '*', n//x)
            break
    else:
        # break 없이 루프가 끝났을 때 실행
        print(n, 'is a prime number')
```

---

# 4.6 pass 문

**아무것도 하지 않는 문장.** 문법적으로 문장이 필요하지만 할 일이 없을 때 사용한다.

```python
while True:
    pass  # 키보드 인터럽트를 기다림

class MyEmptyClass:
    pass  # 최소한의 클래스

def initlog(*args):
    pass  # 나중에 구현할 함수
```

> 💡 Python 3.10+에서는 `pass` 대신 `...` (Ellipsis)를 플레이스홀더로 사용하기도 한다.

---

# 4.7 match 문 (Python 3.10+)

표현식의 값을 여러 패턴과 비교하는 **패턴 매칭** 구문. C의 `switch`보다 강력하다.

```python
def http_error(status):
    match status:
        case 400:
            return "Bad request"
        case 404:
            return "Not found"
        case 418:
            return "I'm a teapot"
        case _:          # 와일드카드 (항상 매칭)
            return "Something's wrong"
```

**주요 기능:**

- `|`로 여러 리터럴을 결합: `case 401 | 403 | 404:`
- 튜플/리스트 언패킹으로 변수 바인딩: `case (0, y):`
- 클래스 패턴 매칭: `case Point(x=0, y=y):`
- 가드 조건 추가: `case Point(x, y) if x == y:`
- `as` 키워드로 서브패턴 캡처: `case (Point(x1, y1), Point(x2, y2) as p2):`
- 명명 상수는 반드시 점 표기법 사용: `case Color.RED:`

---

# 4.8 함수 정의하기

`def` 키워드로 함수를 정의한다.

```python
def fib(n):
    """n 보다 작은 피보나치 수열을 인쇄합니다."""
    a, b = 0, 1
    while a < n:
        print(a, end=' ')
        a, b = b, a+b
    print()
```

**핵심 개념:**

- **독스트링(docstring):** 함수 바디 첫 줄의 문자열 리터럴. 문서화에 사용된다.
- **스코프 규칙:** 변수 참조 순서는 지역 → 전역 → 내장 순서이다.
- **인자 전달 방식:** 값에 의한 호출(call by value)이지만, 값은 **객체 참조**이다.
- `return` 문이 없으면 `None`을 반환한다.
- 함수는 **일급 객체**로, 다른 변수에 할당 가능하다: `f = fib`

```python
def fib2(n):
    """n 보다 작은 피보나치 수열 리스트를 반환"""
    result = []
    a, b = 0, 1
    while a < n:
        result.append(a)
        a, b = b, a+b
    return result
```

---

# 4.9 함수 정의 더 보기

## 4.9.1 기본 인자 값

매개변수에 기본값을 지정하면 인자 생략이 가능하다.

```python
def ask_ok(prompt, retries=4, reminder='Please try again!'):
    ...
```

> ⚠️ **주의:** 기본값은 함수 정의 시점에 **한 번만** 평가된다. 가변 객체(리스트, 딕셔너리)를 기본값으로 사용하면 호출 간에 공유된다!

```python
# ❌ 잘못된 예시 (호출 간 리스트 공유됨)
def f(a, L=[]):
    L.append(a)
    return L

# ✅ 올바른 예시
def f(a, L=None):
    if L is None:
        L = []
    L.append(a)
    return L
```

## 4.9.2 키워드 인자

`kwarg=value` 형식으로 함수를 호출할 수 있다.

**규칙:**

- 키워드 인자는 위치 인자 **뒤에** 와야 한다.
- 같은 인자에 값을 두 번 전달할 수 없다.
- `*name`: 남은 위치 인자를 튜플로 받음
- `**name`: 남은 키워드 인자를 딕셔너리로 받음

## 4.9.3 특수 매개 변수

```
def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):
      -----------    ----------     ----------
           |              |              |
      위치 전용      위치-키워드      키워드 전용
```

| 구분 | 기호 | 설명 |
| --- | --- | --- |
| 위치 전용 | `/` 앞 | 키워드로 전달 불가, 순서가 중요 |
| 위치-키워드 | `/`와 `*` 사이 | 둘 다 가능 (기본) |
| 키워드 전용 | `*` 뒤 | 반드시 이름을 명시해야 함 |

## 4.9.4 임의의 인자 목록

`*args`로 임의 개수의 위치 인자를 튜플로 받는다.

```python
def concat(*args, sep="/"):
    return sep.join(args)

concat("earth", "mars", "venus")       # 'earth/mars/venus'
concat("earth", "mars", sep=".")       # 'earth.mars'
```

## 4.9.5 인자 목록 언패킹

- `*리스트`로 위치 인자를 언패킹: `range(*[3, 6])`
- `**딕셔너리`로 키워드 인자를 언패킹: `parrot(**d)`

## 4.9.6 람다 표현식

`lambda`로 작고 이름 없는 함수를 만든다. **단일 표현식만 가능.**

```python
f = lambda a, b: a + b

# 정렬 키로 활용
pairs = [(1, 'one'), (2, 'two'), (3, 'three')]
pairs.sort(key=lambda pair: pair[1])
```

## 4.9.7 도큐멘테이션 문자열

- 첫 줄: 짧고 간결한 요약 (대문자 시작, 마침표 종료)
- 두 번째 줄: 빈 줄 (요약과 설명 분리)
- 이후: 호출 규약, 부작용 등 상세 설명

## 4.9.8 함수 어노테이션

함수의 타입 힌트를 위한 선택적 메타데이터.

```python
def f(ham: str, eggs: str = 'eggs') -> str:
    return ham + ' and ' + eggs
```

---

# 4.10 코딩 스타일 (PEP 8)

- **들여쓰기:** 4 스페이스 (탭 사용 금지)
- **줄 길이:** 79자 이하
- **빈 줄:** 함수/클래스 사이에 삽입
- **주석:** 별도의 줄로 작성
- **독스트링:** 항상 사용하기
- **네이밍:** 클래스는 `UpperCamelCase`, 함수/메서드는 `lowercase_with_underscores`
- **인코딩:** UTF-8 또는 ASCII 사용 권장
