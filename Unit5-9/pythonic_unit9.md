### 1. 이름과 객체

- 객체는 개체성, 여러 개의 이름이 같은 객체에 연결 가능 = 에일리어싱
- 가변 객체를 수반할 때 에일리어싱이 극적 효과 줄 수 있음

### 2. 파이썬 스코프와 이름 공간

- 이름 공간 : 이름에서 객체로 가는 매핑
    - 대부분 현재 파이썬 딕셔너리로 구현
    - 서로 다른 이름 공간들의 이름 간에는 아무런 관계 X
- 어트리뷰트 : 점 뒤에 오는 모든 이름
    - 모듈에 있는 이름들에 대한 참조는 어트리뷰트 참조
    - 어트리뷰트는 읽기 전용, 쓰기 가능
    - 쓰기 가능한 어트리뷰트는 대입, del 삭제 모두 가능
- 모듈의 전역 이름 공간은 모듈 정의를 읽는 동안 만들어짐
- 모듈 이름 공간은 인터프리터가 끝날 때 까지 남음
- 재귀적 호출은 각각 자기 자신만의 지역 이름 공간 가짐
- 스코프 : 이름 공간을 직접 액세스할 수 있는 파이썬 프로그램의 텍스트적인 영역
- 이름을 global로 선언하면 전역 이름 포함 스코프로 감 ↔ nonlocal
- 파이썬의 특징은 global 이나 nonlocal 문이 없을 때 이름에 대입하면 항상 가장 내부의 스코프에 감
    - del x 는 지역 스코프가 참조하는 이름 공간에서 x 의 연결을 제거함
    - global 문은 특정 변수가 전역 스코프에, 재연결되어야할 때
    - nonlocal 문은특정 변수가 둘러싸는 스코프에 있으며 재연결되어야 할 때

   

### 3. 클래스와의 첫 만남

- 클래스 정의 시 새 이름 공간 만들어지고 지역 스코프로 사용
- 클래스 객체는두 종류의 연산을 지원
    - 어트리뷰트 참조
    - 인스턴스 만들기 : __init__(self) 메서드 정의, 새로 만들어진 클래스 인스턴스에 대해 자동 호출
- 인스턴스 객체로는 어트리뷰트 참조가 가능
    - 데이터 어트리뷰트
    - 메서드 (객체에 속하는 함수)
- 메서드 객체와 함수 객체는 다름
    - 메서드는 데이터 어트리뷰트가 아닌 인스턴스 어트리뷰트를 참조하면그것의 클래스가 검색 됨
    - 이름이 함수 객체인 올바른 클래스 어트리뷰트면 인스턴스 객체와 함수 객체에 대한 참조가 함께 메서드 객체로 포장

- 인스턴스 변수 : 인스턴스별 데이터를 위한 것
- 클래스 변수 : 그 클래스에서모든인스턴스에서 공유되는 어트리뷰트와 메서드를 위한 것
- 가변 객체가 클래스 변수로 사용될 때 하나의 가변 객체가 모든 인스턴스들에 공유되기에 인스턴스 변수 사용해야 함

### 4. 기타 주의사항들

- 인스턴스와 클래스 모두에서 같은 어트리뷰트 이름이 등장하면, 어트리뷰트 조회는 인스턴스를 우선
- 파이썬에서 데이터 은닉을 강제할 방법은 없다
- 클래스 어트리뷰트인 모든 함수는 그 클래스의 인스턴스들을 위한 메서드를 정의
- 메서드는 전역 이름을 참조할 수 있음. 메서드에 결합한 전역 스코프는 그것의 정의를 포함하는 모듈

 

### 5. 상속

```python
class DerivedClassName(BaseClassName):
    <statement-1>
    .
    <statement-N>
    
class DerivedClassName(modname.BaseClassName):
# 베이스 클래스가 다른 모듈에 정의되어 있을 때
```

- 파생 클래스는 베이스 클래스의 메서드 재정의 가능
- 파이썬에서 모든 메서드는 실질적으로 virtual 임
- 상속과 함께 사용할 수 있는 내장함수
    - isinstance(obj, int) : 인스턴스 형을 검사, obj가 int 거나 int에서 파생됨 → True
    - issubclass(obj, a) : 클래스 상속 검사, obj 가 a 의 서브 클래스면 True

```python
class DerivedClassName(Base1, Base2, Base3):
    <statement-1>
    .
    <statement-N>
```

- 다중상속, 상속된 어트리뷰트들의 검색을 깊이 우선으로, 왼쪽에서 오른쪽으로, 계층 구조에서 겹치는 같은 클래스를 두 번 검색하지 않는 것
- 메서드 결정 순서 : super() 로의 협력적 호출 지원 위해 동적으로 변경
- 동적 순서 : 다이아몬드 관계 해결 위함, 동적인 알고리즘이 검색순서를 선형화 함. 각 부모를 한 번만 호출, 단조적이게만듦

  

### 6. 비공개변수

- 파이썬에 객체내부에서만 액세스 가능한 비공개 인스턴스 변수는 없음

```python
class Mapping:
    def __init__(self, iterable):
        self.items_list = []
        self.__update(iterable)

    def update(self, iterable):
        for item in iterable:
            self.items_list.append(item)

    __update = update   # 기존 update() 메서드의 비공개 사본

class MappingSubclass(Mapping):

    def update(self, keys, values):
        # update() 에 새로운 서명을 제공하지만
        # __init__() 를 망가뜨리진 않습니다
        for item in zip(keys, values):
            self.items_list.append(item)
```

- 서브 클래스에서 정의된 이름들과의 충돌을 막기 위해 이름 뒤섞기 메커니즘 지원
    - 최소 두 개의 밑줄 시작, 최대 한 개의 밑줄로 끝남

 * exec(), eval()로 전달된 코드는 호출 클래스의 클래스 이름을 현재 클래스로 여기지 않음 - global 문의 효과와 유사

### 7. 잡동사니

- 몇몇 이름 붙은 데이터 항목들을 함께 묶어주는 struct 와 유사한 데이터형, dataclasses 를 사용하는 것이 일반적

```python
from dataclasses import dataclass

@dataclass
class Employee:
    name: str
    dept: str
    salary: int
```

### 8. 이터레이터

- for 문은 컨테이너 객체에 대해 iter()를 호출함.
    - 이 함수는 메서드 __next__()를 정의하는 이터레이터 객체를 돌려줌 → 메서드는 컨테이너의 요소들을 한 번에하나씩 액세스
    - 남은 요소가 없으면   __next__()는 StopIteration 예외 발생 루프 종료

### 9. 제너레이터

- 이터레이터를 만드는 도구
- 값을 돌려주고 싶을 때마다 yield 문 사용
- 제너레이터에서 next()가 호출될 때마다 제너레이터는 떠난 곳에서 실행을 재개 (마지막 실행 문 기억)

```python
def reverse(data):
    for index in range(len(data)-1, -1, -1):
        yield data[index]
```

### 10. 제너레이터 표현식

- 간단한 제너레이터는 리스트 컴프리헨션과 유사. 대괄호 대신 괄호 사용
- 간결, 효율성 떨어짐, 리스트 컴프리헨션보다는 메모리 덜 씀